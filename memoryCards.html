<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>è®°å¿†å¡ç‰‡</title>

<style>
body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    background: #f5f7fa;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
}
#tags { display:flex; flex-wrap:wrap; gap:8px; padding:12px 16px; }
#progress { padding:10px 16px; font-size:18px; text-align:center; }
.card {
    flex:1; margin:20px; background:#fff; border-radius:20px;
    border:4px solid #1565c0;
    display:flex; flex-direction:column; justify-content:center; align-items:center;
    font-size:34px; font-weight:700; text-align:center; padding:32px; cursor:pointer;
}
.card.back { border-color:#999; }
.group { font-size:16px; color:#666; margin-bottom:12px; }
#buttons { display:flex; gap:12px; padding:12px; }
.btn {
    flex:1; height:64px; border-radius:16px; border:none;
    font-size:22px; font-weight:700; color:#fff;
}
.easy{background:#43a047}
.medium{background:#757575}
.forget{background:#e53935}
.export{background:#1565c0}
</style>
</head>

<body>

<div id="tags"></div>
<div id="progress">åŠ è½½ä¸­â€¦</div>

<div class="card" id="card">
    <div class="group" id="group"></div>
    <div id="content">åŠ è½½ä¸­â€¦</div>
</div>

<div id="buttons">
    <button class="btn easy" onclick="mark('easy')">ç®€å•</button>
    <button class="btn medium" onclick="mark('medium')">ä¸€èˆ¬</button>
    <button class="btn forget" onclick="mark('forget')">å¿˜è®°</button>
</div>

<div id="buttons">
    <button class="btn export" onclick="exportLogs()">å¯¼å‡ºæ—¥å¿— CSV</button>
</div>

<script>
const CSV_URL =
  'https://raw.githubusercontent.com/FreyaLLL/memory_cards/refs/heads/main/cards.csv';

/* ===== çŠ¶æ€ ===== */
let cards = [];
let current = null;
let showBack = false;
let currentTag = 'ALL';
let done = 0;
let round = 1;

/* ===== æ—¥å¿— ===== */
let logs = JSON.parse(localStorage.getItem('memory_logs') || '[]');
let cardStartTime = 0;

/* ===== ç»„å¡ ===== */
let groupQueue = [];
let currentGroup = null;

const tagsEl = document.getElementById('tags');
const cardEl = document.getElementById('card');
const contentEl = document.getElementById('content');
const groupEl = document.getElementById('group');
const progressEl = document.getElementById('progress');

/* ===== CSV è§£æ ===== */
function parseCSV(text){
    const rows=[]; let row=[],field='',q=false;
    for(let i=0;i<text.length;i++){
        const c=text[i],n=text[i+1];
        if(c=='"'&&q&&n=='"'){field+='"';i++}
        else if(c=='"')q=!q
        else if(c==','&&!q){row.push(field);field=''}
        else if((c=='\n'||c=='\r')&&!q){
            if(field||row.length)row.push(field);
            if(row.length)rows.push(row);
            row=[];field='';
        } else field+=c;
    }
    if(field||row.length){row.push(field);rows.push(row)}
    return rows;
}

/* ===== åŠ è½½ ===== */
fetch(CSV_URL).then(r=>r.text()).then(t=>{
    cards=parseCSV(t).slice(1).map(r=>{
        const [id,front,back,tag,level,group]=r.map(v=>(v||'').trim());
        if(!front||!back)return null;
        return {id,front,back,tag,level,group,done:false};
    }).filter(Boolean);
    initTags();
    nextCard();
});

/* ===== tags ===== */
function initTags(){
    tagsEl.innerHTML='';
    const s=new Set();
    cards.forEach(c=>{
        if(c.tag)s.add(c.tag);
        if(c.group)s.add('ç»„å¡');
        if(c.level==='new')s.add('new');
    });
    addTag('ALL','å…¨éƒ¨');
    [...s].forEach(t=>addTag(t,t));
}
function addTag(v,l){
    const b=document.createElement('button');
    b.textContent=l;
    b.style.cssText=`
      padding:6px 14px;border-radius:14px;border:none;font-weight:700;
      background:${v===currentTag?'#1565c0':'#e3f2fd'};
      color:${v===currentTag?'#fff':'#1565c0'};
    `;
    b.onclick=()=>{currentTag=v; resetRound(); initTags(); nextCard();};
    tagsEl.appendChild(b);
}

/* ===== å¡ç‰‡ ===== */
cardEl.onclick=()=>{
    if(!current)return;
    showBack=!showBack;
    contentEl.textContent=showBack?current.back:current.front;
    cardEl.classList.toggle('back',showBack);
};

function nextCard(){
    if(currentTag==='ç»„å¡'){
        if(!groupQueue.length){
            const gs=[...new Set(cards.filter(c=>!c.done&&c.group).map(c=>c.group))];
            if(!gs.length)return finishRound();
            currentGroup=gs[Math.floor(Math.random()*gs.length)];
            groupQueue=cards.filter(c=>!c.done&&c.group===currentGroup);
        }
        current=groupQueue.shift();
    } else {
        const pool=cards.filter(c=>!c.done&&(
            currentTag==='ALL'||
            (currentTag==='new'&&c.level==='new')||
            c.tag===currentTag
        ));
        if(!pool.length)return finishRound();
        current=pool[Math.floor(Math.random()*pool.length)];
    }

    showBack=false;
    cardEl.classList.remove('back');
    contentEl.textContent=current.front;
    groupEl.textContent=current.group?`ç»„ï¼š${current.group}`:'';
    cardStartTime=Date.now();
    updateProgress();
}

/* ===== è®°å½•æ—¥å¿— ===== */
function mark(result){
    if(!current)return;

    const time=(Date.now()-cardStartTime)/1000;

    logs.push({
        card_id: current.id,
        result,
        time: Number(time.toFixed(2))
    });

    localStorage.setItem('memory_logs', JSON.stringify(logs));

    current.done=true;
    done++;
    nextCard();
}

/* ===== å¯¼å‡ºæ—¥å¿— CSVï¼ˆæœ€ç»ˆå°ç‰ˆï¼‰ ===== */
function exportLogs(){
    if(!logs.length){
        alert('æš‚æ— æ—¥å¿—');
        return;
    }

    let csv = 'card_id,result,time\n';
    logs.forEach(l=>{
        csv += `${l.card_id},${l.result},${l.time}\n`;
    });

    // â­ æ—¥æœŸæ–‡ä»¶å
    const dateStr = new Date().toISOString().slice(0,10);

    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `logs_${dateStr}.csv`;
    a.click();

    URL.revokeObjectURL(url);
}

/* ===== è½®æ¬¡ ===== */
function finishRound(){
    contentEl.textContent='å®Œæˆä¸€è½® ğŸ‰';
    groupEl.textContent='';
    updateProgress();
    setTimeout(()=>{
        round++;
        resetRound();
        nextCard();
    },800);
}
function resetRound(){
    cards.forEach(c=>c.done=false);
    done=0;
    groupQueue=[];
    currentGroup=null;
}

/* ===== è¿›åº¦ ===== */
function updateProgress(){
    const left=cards.filter(c=>!c.done).length;
    progressEl.textContent=`ç¬¬ ${round} è½® ï½œ å·²å®Œæˆ ${done}/${cards.length} ï½œ å‰©ä½™ ${left}`;
}
</script>

</body>
</html>
